<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>openmdao.main.interfaces &mdash; OpenMDAO Documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMDAO Documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for openmdao.main.interfaces</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interfaces for the OpenMDAO project.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># pylint: disable=E0213,E0211,W0232</span>

<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implements</span><span class="p">,</span> <span class="n">classImplements</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">,</span> <span class="n">Interface</span><span class="p">,</span>\
                           <span class="n">directlyProvides</span>

<span class="kn">from</span> <span class="nn">openmdao.main.constants</span> <span class="kn">import</span> <span class="n">SAVE_CPICKLE</span>


<span class="k">class</span> <span class="nc">IArchitecture</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;parent Assembly&quot;</span><span class="p">)</span>
    <span class="n">data_recorders</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;List of CaseRecorder instances where data from &quot;</span>
                               <span class="s">&quot;the optimization should be stored.&quot;</span><span class="p">)</span>
    <span class="n">param_types</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;list of types of allowed parameters.  &quot;</span>
                            <span class="s">&quot;Valid values are: [&#39;continuous&#39;,&#39;discrete&#39;,&#39;enum&#39;]&quot;</span><span class="p">)</span>
    <span class="n">constraint_types</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;list of types of allowed constraints. &quot;</span>
                                 <span class="s">&quot; Valid values are: [&#39;eq&#39;, &#39;ineq&#39;]&quot;</span><span class="p">)</span>
    <span class="n">num_allowed_objectives</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;number of objectives supported.&quot;</span><span class="p">)</span>
    <span class="n">has_coupling_vars</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;True if coupling variables are required.&quot;</span><span class="p">)</span>
    <span class="n">has_global_des_vars</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;True if the architecture requires a problem &quot;</span>
                                    <span class="s">&quot;formulation with global design variables in it&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;sets up drivers,workflows, and data connections in</span>
<span class="sd">        the assembly to configure the architecture</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;removes all the drivers, workflows, and data connections in the</span>
<span class="sd">        assembly, leaving the assembly cleaned up.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IContainer</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interface for an object containing variables and other IContainers.&quot;&quot;&quot;</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;parent of this Container (or None)&quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;name of this Container&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a Container object to this Container.</span>
<span class="sd">        Returns the added Container object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the child specified by the given dotted path</span>
<span class="sd">        name is contained in this Container.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_dyn_trait</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">trait</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a trait if a trait with the given pathname exists, possibly</span>
<span class="sd">        creating the trait &quot;on-the-fly.&quot; If an attribute exists with the given</span>
<span class="sd">        pathname but no trait is found or can be created, or if pathname</span>
<span class="sd">        references a trait in a parent scope, None will be returned. If no</span>
<span class="sd">        attribute exists with the given pathname within this scope, an</span>
<span class="sd">        AttributeError will be raised.</span>

<span class="sd">        pathname: str</span>
<span class="sd">            Pathname of the desired trait.  May contain dots.</span>

<span class="sd">        iotype: str (optional)</span>
<span class="sd">            Expected iotype of the trait.</span>

<span class="sd">        trait: TraitType (optional)</span>
<span class="sd">            Trait to be used for validation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the object specified by the given</span>
<span class="sd">        path, which may contain &#39;.&#39; characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_pathname</span><span class="p">(</span><span class="n">rel_to_scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return full path name to this container, relative to scope</span>
<span class="sd">        *rel_to_scope*. If *rel_to_scope* is *None*, return the full pathname.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">metadata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of tuples of the form (rel_pathname, obj) for each</span>
<span class="sd">        trait of this Container that matches the given metadata. If recurse is</span>
<span class="sd">        True, also iterate through all child Containers of each Container</span>
<span class="sd">        found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_containers</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of child Containers.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="n">traitpath</span><span class="p">,</span> <span class="n">metaname</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the metadata associated with the trait found using</span>
<span class="sd">        traitpath.  If metaname is None, return the entire metadata dictionary</span>
<span class="sd">        for the specified trait. Otherwise, just return the specified piece</span>
<span class="sd">        of metadata.  If the specified piece of metadata is not part of</span>
<span class="sd">        the trait, None is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the trait indicated by name, or None if not found.  No recursive</span>
<span class="sd">        search is performed if name contains dots.  This is a replacement</span>
<span class="sd">        for the trait() method on HasTraits objects, because that method</span>
<span class="sd">        can return traits that shouldn&#39;t exist. Do not use the trait() function</span>
<span class="sd">        unless you are certain that the named trait exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pre_delete</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any required operations before being deleted.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">post_load</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any required operations after model has been loaded.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the specified child from this container and remove any</span>
<span class="sd">        public trait objects that reference that child. Notify any</span>
<span class="sd">        observers.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">revert_to_defaults</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the values of all of the inputs to their default values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">outstream</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">SAVE_CPICKLE</span><span class="p">,</span> <span class="n">proto</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the state of this object and its children to the given</span>
<span class="sd">        output stream. Pure Python classes generally won&#39;t need to</span>
<span class="sd">        override this because the base class version will suffice, but</span>
<span class="sd">        Python extension classes will have to override. The format</span>
<span class="sd">        can be supplied in case something other than cPickle is needed.</span>

<span class="sd">        outstream: file or string</span>
<span class="sd">            Stream to save to.</span>

<span class="sd">        fmt: int</span>
<span class="sd">            Format for saved data.</span>

<span class="sd">        proto: int</span>
<span class="sd">            Protocol used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of the Variable specified by the given path, which</span>
<span class="sd">        may contain &#39;.&#39; characters. The Variable will be set to the given</span>
<span class="sd">        value, subject to validation and constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cpath_updated</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Called whenever this Container&#39;s position in the Container hierarchy changes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Called once, after this Container has been placed in a rooted Container hierarchy.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IContainerProxy</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Marker interface for proxy containers.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IOverrideSet</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Marker interface for a container that must do it&#39;s own sets rather than</span>
<span class="sd">    having the parent container evaluate it&#39;s member variables as an expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">IVariableTree</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Marker interface for VariableTrees.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IComponent</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interface for an IContainer object that can be executed to update the values of</span>
<span class="sd">    its output variables based on the values of its input variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">check_config</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that this component is properly configured to execute.</span>
<span class="sd">        Classes overriding this method must call the base class method.</span>
<span class="sd">        If strict is True, even configuration warnings should raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run this object. This should include fetching input variables,</span>
<span class="sd">        executing, and updating output variables. Do not override this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_inputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of input values. If valid is not None,</span>
<span class="sd">        the the list will contain names of inputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_outputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of output values. If valid is not None,</span>
<span class="sd">        the the list will contain names of outputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_depends</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples of the form (src_comp_name, dest_comp_name)</span>
<span class="sd">        for each dependency resulting from ExprEvaluators in this Component.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_abs_directory</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return absolute path of execution directory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">outstream</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">SAVE_CPICKLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save sufficient information for a restart. By default, this</span>
<span class="sd">        just calls *save()*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="n">instream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restore state using a checkpoint file. The checkpoint file is</span>
<span class="sd">        typically a delta from a full saved state file. If checkpoint is</span>
<span class="sd">        overridden, this should also be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_file_vars</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return list of (filevarname, filevarvalue, file trait) owned by this</span>
<span class="sd">        component.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Stop this component.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IImplicitComponent</span><span class="p">(</span><span class="n">IComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for a component that represents an implicit function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of state variables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of residual variables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;run a single step to calculate the residual</span>
<span class="sd">        values for the given state var values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">IPseudoComp</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Special interface for Pseudocomps for checking.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">check_config</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that this component is properly configured to execute.</span>
<span class="sd">        Classes overriding this method must call the base class method.</span>
<span class="sd">        If strict is True, even configuration warnings should raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run this object. This should include fetching input variables,</span>
<span class="sd">        executing, and updating output variables. Do not override this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_inputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of input values. If valid is not None,</span>
<span class="sd">        the the list will contain names of inputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_outputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of output values. If valid is not None,</span>
<span class="sd">        the the list will contain names of outputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IDriver</span><span class="p">(</span><span class="n">IComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for objects that manage the iteration of workflows.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">workflow</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;object that knows how to run a single iteration over&quot;</span>
                         <span class="s">&quot; this Driver&#39;s iteration set&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iteration_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a set of names (not pathnames) containing all Components</span>
<span class="sd">        in this Driver&#39;s workflow or any of its sub-workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">requires_derivs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns True if this Driver requires derivatives. &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ISolver</span><span class="p">(</span><span class="n">IDriver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for drivers that are solvers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">IOptimizer</span><span class="p">(</span><span class="n">IDriver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for drivers that are optimizers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">IAssembly</span><span class="p">(</span><span class="n">IComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for objects that contain a driver and its workflow components.&quot;&quot;&quot;</span>

    <span class="n">driver</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;object that manage&#39;s the iteration of a workflow&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connects one source variable to one destination variable.</span>

<span class="sd">        srcpath: str</span>
<span class="sd">            Name of source variable.</span>

<span class="sd">        destpath: str</span>
<span class="sd">            Name of destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the connection between one source variable and one</span>
<span class="sd">        destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IFactory</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object that creates and returns objects based on a type string.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typname</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">res_desc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ctor_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an object of type *typname,* (or a proxy to it if it resides</span>
<span class="sd">        in another process) using the specified package version, server</span>
<span class="sd">        location, and resource description. Returns None if this factory is</span>
<span class="sd">        unable to create the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_available_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list tuples of the form (typename, meta_dict) for all</span>
<span class="sd">        available types based on the given list of entry point groups. If</span>
<span class="sd">        groups is None, all types matching any openmdao entry point group will</span>
<span class="sd">        be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typname</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return constructor argument signature for *typname,* using the</span>
<span class="sd">        specified package version. The return value is a dictionary:</span>

<span class="sd">        args: list</span>
<span class="sd">            List of 1 or 2-element lists. The first element is the argument</span>
<span class="sd">            name, the second element is the default value.</span>

<span class="sd">        varargs: string</span>
<span class="sd">            The name of the &#39;*&#39; argument.</span>

<span class="sd">        kwargs: string</span>
<span class="sd">            The name of the &#39;**&#39; argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is optional, but if present it will be called by</span>
<span class="sd">        the FactoryManager prior to the factory being removed from the</span>
<span class="sd">        list of active factories.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IResourceAllocator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object responsible for allocating CPU/disk resources for a particular</span>
<span class="sd">    host, cluster, load balancer, etc.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">max_servers</span><span class="p">(</span><span class="n">resource_desc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum number of servers which could be deployed for</span>
<span class="sd">        `resource_desc`.  The value needn&#39;t be exact, but performance may</span>
<span class="sd">        suffer if it overestimates.  The value is used to limit the number</span>
<span class="sd">        of concurrent evaluations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">time_estimate</span><span class="p">(</span><span class="n">resource_desc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `(estimate, criteria)` indicating how well this resource</span>
<span class="sd">        allocator can satisfy the `resource_desc` request.  The estimate will</span>
<span class="sd">        be:</span>

<span class="sd">        - &gt;0 for an estimate of walltime (seconds).</span>
<span class="sd">        -  0 for no estimate.</span>
<span class="sd">        - -1 for no resource at this time.</span>
<span class="sd">        - -2 for no support for `resource_desc`.</span>

<span class="sd">        The returned criteria is a dictionary containing information related</span>
<span class="sd">        to the estimate, such as load averages, unsupported resources, etc.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">deploy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">resource_desc</span><span class="p">,</span> <span class="n">criteria</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deploy a server suitable for `resource_desc`.</span>
<span class="sd">        `criteria` is the dictionary returned by :meth:`time_estimate`.</span>
<span class="sd">        Returns a proxy to the deployed server.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_allocated_components</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list of tuples `(hostname, pid, component_name)` for each</span>
<span class="sd">        Component currently allocated by this allocator.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseIterator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterator that returns Case objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of Cases&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseRecorder</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A recorder of Cases.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">startup</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any operations required to start-up this recorder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register names for input and output data coming from `driver`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">record_constants</span><span class="p">(</span><span class="n">constants</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record constant data.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">case_uuid</span><span class="p">,</span> <span class="n">parent_uuid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record input and output data from `driver`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_iterator</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that matches the format that this recorder uses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any operations required to shut-down this recorder.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseFilter</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selects cases.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">seqno</span><span class="p">,</span> <span class="n">case</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if `case` should be used, where `seqno` is the index</span>
<span class="sd">        of `case` in the sequence of cases.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IDOEgenerator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterator that returns lists of normalized values that are mapped</span>
<span class="sd">    to design variables by a Driver.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_parameters</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;number of parameters in the DOE&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator object where each iteration returns</span>
<span class="sd">        a set of values in the range [0., 1.].</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IUncertainVariable</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A variable which supports uncertainty&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns either value from expected() or from sample() depending on</span>
<span class="sd">        the global or local uncertainty setting.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">expected</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Calculates the expected value of the uncertainty distribution.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Generates a random number from an uncertain distribution.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasCouplingVars</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface to support the declaration of coupling variables</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_coupling_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indep</span><span class="p">,</span> <span class="n">dep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;adds a new pair (indep/dep) of coupling variables</span>

<span class="sd">        indep: str</span>
<span class="sd">            name of the independent variable, or the variable</span>
<span class="sd">            that should be varied, to meet the coupling constraint</span>
<span class="sd">        dep: str</span>
<span class="sd">            name of the dependent variable, or the variable that</span>
<span class="sd">            needs to be forced to be consistent with the independent</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_coupling_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">couple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removes the pair (indep/dep) of coupling variables.</span>

<span class="sd">        couple: tuple of str</span>
<span class="sd">            two tuple of (&lt;indep&gt;,&lt;dep&gt;) to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_coupling_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a ordered list of names of the coupling variables&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_coupling_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removes all coupling variables&quot;&quot;&quot;</span>

<span class="c">#class IHasGlobalDesVars(Interface):</span>
    <span class="c">#&quot;&quot;&quot;Interface for managing global design variables in assemblies</span>

    <span class="c">#parent: Assembly</span>
        <span class="c">#containing assembly where the HasGlobalDesVars lives.</span>
    <span class="c">#&quot;&quot;&quot;</span>

    <span class="c">#def add_global_des_var(name,targets,low,high,scalar=1.0,adder=0.0):</span>
        <span class="c">#&quot;&quot;&quot;adds a global design variable to the assembly</span>

        <span class="c">#name: str</span>
            <span class="c">#name given to the global design variable</span>
        <span class="c">#targets: list of str</span>
            <span class="c">#names of the component variables that this global design variable should link to</span>
        <span class="c">#low: float</span>
            <span class="c">#minimum allowed value for the global design variable</span>
        <span class="c">#high: float</span>
            <span class="c">#maximum allowed value for the global design variable</span>
        <span class="c">#scalar: float (optional)</span>
            <span class="c">#default: 1.0. scalar value which is multiplied by the value of the global design</span>
            <span class="c">#variable before setting target values</span>
        <span class="c">#adder: float (optiona)</span>
            <span class="c">#default: 0.0. amount which is added to the value of the global</span>
            <span class="c">#design variable before setting target values</span>
        <span class="c">#&quot;&quot;&quot;</span>

    <span class="c">#def remove_global_des_var(name):</span>
        <span class="c">#&quot;&quot;&quot;removed the global design variable from the assembly&quot;&quot;&quot;</span>

    <span class="c">#def clear_global_des_vars():</span>
        <span class="c">#&quot;&quot;&quot;removes all global design variables from the assembly&quot;&quot;&quot;</span>

    <span class="c">#def list_global_des_vars():</span>
        <span class="c">#&quot;&quot;&quot;returns a list of all the names of global design variable objects in the assembly&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">IPredictor</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_uncertain_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a deterministic value into an uncertain quantity which</span>
<span class="sd">        matches the uncertain variable type the surrogate predicts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predicts a value of from the surrogate model for the given independent values in X.</span>

<span class="sd">        X: list</span>
<span class="sd">            The input values for which the predicted output is requested.</span>

<span class="sd">        Returns the predicted output value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">ISurrogate</span><span class="p">(</span><span class="n">IPredictor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trains the surrogate model, based on the given training data set.</span>

<span class="sd">        X: iterator of lists</span>
<span class="sd">            Values representing the training case input history.</span>
<span class="sd">        y: iterator</span>
<span class="sd">            Training case output history for this surrogate&#39;s output,</span>
<span class="sd">            which corresponds to the training case input history given by X.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IMultiFiSurrogate</span><span class="p">(</span><span class="n">IPredictor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">train_multifi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trains the surrogate model, based on the given training data set.</span>

<span class="sd">        X: list of (m samples, n inputs) lists of lists</span>
<span class="sd">            Values representing the multi-fidelity training case input history.</span>
<span class="sd">        y: list of lists</span>
<span class="sd">            Training case output history for this surrogate&#39;s output,</span>
<span class="sd">            which corresponds to the multi-fidelity training case input history</span>
<span class="sd">            given by X.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasParameters</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">add_parameter</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a parameter to the driver.</span>

<span class="sd">        param_name: str</span>
<span class="sd">            Name of the parameter to add.</span>
<span class="sd">        low: number (optional)</span>
<span class="sd">            Minimum allowed value the optimzier can use for this parameter. If not specified,</span>
<span class="sd">            then the *low* value from the variable is used.</span>
<span class="sd">        high: number (optional)</span>
<span class="sd">            Maximum allowed value the optimizer can use for this parameter. If not specified,</span>
<span class="sd">            then the *high* value from the variable is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_parameter</span><span class="p">(</span><span class="n">param_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified parameter. Raises a KeyError if param_name is not found.</span>

<span class="sd">        param_name: str</span>
<span class="sd">            Name of the parameter to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_param_targets</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Lists the targets of all parameters.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_parameters</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all parameters.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of parameter objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pushes the values in the X input array into the corresponding</span>
<span class="sd">        variables in the model.</span>

<span class="sd">        X: iterator</span>
<span class="sd">            iterator of input values with an order defined to match the order</span>
<span class="sd">            of parameters returned by the get_parameters method. X must support</span>
<span class="sd">             the len() function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">total_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of values to be set.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return evaluated parameter values.</span>

<span class="sd">        dtype: string or None</span>
<span class="sd">            If not None, return an array of this dtype. Otherwise just return</span>
<span class="sd">            a list (useful if parameters may be of different types).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return lower bound values.</span>

<span class="sd">        dtype: string or None</span>
<span class="sd">            If not None, return an array of this dtype. Otherwise just return</span>
<span class="sd">            a list (useful if parameters may be of different types).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return upper bound values.</span>

<span class="sd">        dtype: string or None</span>
<span class="sd">            If not None, return an array of this dtype. Otherwise just return</span>
<span class="sd">            a list (useful if parameters may be of different types).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_fd_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return fd_step values, they may include None.</span>

<span class="sd">        dtype: string or None</span>
<span class="sd">            If not None, return an array of this dtype. Otherwise just return</span>
<span class="sd">            a list (useful if it&#39;s valid to have None for a step size).</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasEvents</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_event</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an event variable to be set when set_events is called.</span>

<span class="sd">        name: str</span>
<span class="sd">            Name of the event variable that should be set during execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_event</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified event variable.</span>

<span class="sd">        name: str</span>
<span class="sd">            Name of the event to be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the list of event variables to be set.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Remove all event variables from the list.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Set all events in the event list.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasEqConstraints</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing equality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an equality constraint.</span>

<span class="sd">        expr_string: str</span>
<span class="sd">            A string containing an assignment, e.g., &#39;a = 2*b+5&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the given constraint.</span>

<span class="sd">        expr_string: str</span>
<span class="sd">            A string matching the constraint to be</span>
<span class="sd">            removed.  Whitespace is ignored when matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_eq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dictionary of equality constraint objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">total_eq_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of equality constraint values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_eq_constraints</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the constraint expressions and returns a list of values.</span>
<span class="sd">        The form of the constraint is transformed if necessary such that the</span>
<span class="sd">        right-hand-side is 0.0.  The values returned are the evaluation of the</span>
<span class="sd">        left-hand-side.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasIneqConstraints</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing inequality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an inequality constraint as a string containing an inequality,</span>
<span class="sd">        for example, &#39;a &gt; b&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the constraint matching the given string. Whitespace is ignored.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_ineq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of inequality constraint objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">total_ineq_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of inequality constraint values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_ineq_constraints</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the constraint expressions and returns a list of values. Constraints</span>
<span class="sd">        are coerced into a form where the right-hand-side is 0., and the value returned</span>
<span class="sd">        is the evaluation of the left-hand-side.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasConstraints</span><span class="p">(</span><span class="n">IHasEqConstraints</span><span class="p">,</span> <span class="n">IHasIneqConstraints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing both equality and inequality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a constraint as a string containing</span>
<span class="sd">        an assignment or an inequality, e.g., &#39;a=b&#39; or &#39;a&lt;=b&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of constraint objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">total_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of constraint values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_constraints</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the constraint expressions and returns a list of values.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHas2SidedConstraints</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects that can accept constraints defined like</span>
<span class="sd">    a &lt; x &lt; b, where x is a variable and a and b are constants.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_2sided_constraint</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                               <span class="n">linear</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an 2-sided constraint as four strings; a left-hand side, a</span>
<span class="sd">        center, a right-hand side, and a comparator (&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&lt;=&#39;, or &#39;&gt;=&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_2sided_constraints</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of inequality constraint objects.</span>

<span class="sd">        linear: obj</span>
<span class="sd">            Set to True or False to return linear or nonlinear constraints.</span>
<span class="sd">            Default is None, for all constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_2sided_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of strings containing constraint expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_2sided_constraint_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of outputs suitable for calc_gradient().&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasObjectives</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects having a multiple objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_objectives</span><span class="p">(</span><span class="n">obj_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes an iterator of objective strings and creates</span>
<span class="sd">        objectives for them in the driver.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_objective</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an objective to the driver.</span>

<span class="sd">        expr: string</span>
<span class="sd">            String containing the objective expression.</span>
<span class="sd">         &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_objective</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified objective expression. Spaces within</span>
<span class="sd">        the expression are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_objectives</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_objectives</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of values of the evaluated objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_depends</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples of the form (src_comp_name, dest_comp_name)</span>
<span class="sd">        for each dependency introduced by our objectives.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasObjective</span><span class="p">(</span><span class="n">IHasObjectives</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects having a single objective.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_objective</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the evaluated objective.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasResponses</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects having a responses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_responses</span><span class="p">(</span><span class="n">response_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes an iterator of response strings and creates</span>
<span class="sd">        responses for them in the driver.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_response</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an response to the driver.</span>

<span class="sd">        expr: string</span>
<span class="sd">            String containing the response expression.</span>
<span class="sd">         &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_response</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified response expression. Spaces within</span>
<span class="sd">        the expression are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_responses</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all responses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_responses</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of values of the evaluated responses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_depends</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples of the form (src_comp_name, dest_comp_name)</span>
<span class="sd">        for each dependency introduced by our responses.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IVariable</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Validates that the specified value is valid and can be assigned</span>
<span class="sd">        to the data value corresponding to this Variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">ISystem</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">obj_has_interface</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">ifaces</span><span class="p">):</span>
<div class="viewcode-block" id="obj_has_interface"><a class="viewcode-back" href="../../../srcdocs/packages/openmdao.main.html#openmdao.main.interfaces.obj_has_interface">[docs]</a>    <span class="sd">&quot;&quot;&quot;Returns True if the specified object implements one of the interfaces</span>
<span class="sd">    specified.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">iface</span> <span class="ow">in</span> <span class="n">ifaces</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://openmdao.org">
 <img src="../../../_static/OpenMDAO_Logo_200w_padded.png"
border="0" alt="OpenMDAO Home"/>
</a>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright none.
      Last updated on Apr 23, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>