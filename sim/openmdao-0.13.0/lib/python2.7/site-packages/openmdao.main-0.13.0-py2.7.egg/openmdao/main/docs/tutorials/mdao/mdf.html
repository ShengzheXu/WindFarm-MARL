<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Multidisciplinary Design Feasible (MDF) &mdash; OpenMDAO Documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMDAO Documentation" href="../../index.html" />
    <link rel="up" title="MDAO Architectures" href="index.html" />
    <link rel="next" title="Individual Design Feasible (IDF)" href="idf.html" />
    <link rel="prev" title="The Sellar Problem" href="intro.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idf.html" title="Individual Design Feasible (IDF)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="The Sellar Problem"
             accesskey="P">previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../index.html" >OpenMDAO Tutorials</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">MDAO Architectures</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="multidisciplinary-design-feasible-mdf">
<span id="index-0"></span><span id="id1"></span><h1>Multidisciplinary Design Feasible (MDF)<a class="headerlink" href="#multidisciplinary-design-feasible-mdf" title="Permalink to this headline">Â¶</a></h1>
<p>In a Multidisciplinary Design Feasible (MDF) problem, the disciplines are directly coupled
via some kind of solver, and the design variables are optimized all at the top level. The
following spaghetti diagram illustrates MDF applied to the Sellar problem.</p>
<div class="figure align-center">
<img alt="Diagram consists of boxes and arrows to show data flow for MDF applied to the Sellar problem." src="../../_images/Arch-MDF.png" />
<p class="caption">Data Flow for MDF Applied to the Sellar Problem</p>
</div>
<p>Notice in this diagram, that the optimizer at the top has some data that passes from it to each of the disciplines.
In MDF, both the global and local design variables are all controlled by the top level solver. So the data connections
you see represent both.</p>
<p id="index-1">The diagram also shows a solver that takes the output of the component dataflow
and feeds it back into the input. OpenMDAO has two solvers in the standard library: FixedPointIterator
and BroydenSolver. The FixedPointIterator is a solver that performs fixed point iteration,
which means that it keeps driving <tt class="docutils literal"><span class="pre">x_new</span> <span class="pre">=</span> <span class="pre">f(x_old)</span></tt> until convergence is achieved. In
other words, <em>y2</em> is passed from the output of <tt class="docutils literal"><span class="pre">SellarDiscipline2</span></tt> to the input of <tt class="docutils literal"><span class="pre">SellarDiscipline1</span></tt>,
and the loop keeps executing until the change in the value of <em>y2</em> between iterations is
smaller than a tolerance. The BroydenSolver is based on a quasi-Newton-Raphson
algorithm that uses a Broyden update to approximate the Jacobian. This solver reads
the output and calculates a new input each iteration. Convergence is achieved when the
residual between the output and input is driven to zero.</p>
<p>An important thing to take note of in the problem setup for MDF is the presence of
nested driver and multiple workflows. Drivers can be nested in OpenMDAO using WorkFlows
in the iteration hierarchy. A <a class="reference internal" href="../../glossary.html#term-workflow"><em class="xref std std-term">WorkFlow</em></a> is an object that determines execution
order for a group of Components. Each driver contains a single WorkFlow. For
each iteration, a Driver will execute one pass through the WorkFlow, executing
the components contained therein in the order the WorkFlow prescribes.
Although in many cases a WorkFlow contains just Components, it can also
contain Drivers, which then have thier own workflows. This allows nested iterative processes to be created. The
following diagram shows an iteration hierarchy for the MDF problem.</p>
<div class="figure align-center">
<img alt="Diagram showing the Optimizer, workflow for the Optimizer, and workflow for the Solver" src="../../_images/Arch-MDF-OpenMDAO.png" />
<p class="caption">Iteration Hierarchy for the MDF Problem</p>
</div>
<p>Note that this iteration hierarchy does not contain any information about the data
connections necessary to complete the MDF implementation. Workflows describe only
process.</p>
<p>Now, let&#8217;s take the iteration hierarchy we just discussed and put in into an
assembly, so we can actually run it.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span><span class="p">,</span> <span class="n">set_as_top</span>
<span class="kn">from</span> <span class="nn">openmdao.lib.drivers.api</span> <span class="kn">import</span> <span class="n">SLSQPdriver</span><span class="p">,</span> <span class="n">FixedPointIterator</span>

<span class="kn">from</span> <span class="nn">openmdao.lib.optproblems</span> <span class="kn">import</span> <span class="n">sellar</span>

<span class="k">class</span> <span class="nc">SellarMDF</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Optimization of the Sellar problem using MDF</span>
<span class="sd">    Disciplines coupled with FixedPointIterator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly with this problem</span>

<span class="sd">        Optimal Design at (1.9776, 0, 0)</span>

<span class="sd">        Optimal Objective = 3.18339&quot;&quot;&quot;</span>

        <span class="c"># create Optimizer instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;driver&#39;</span><span class="p">,</span> <span class="n">SLSQPdriver</span><span class="p">())</span>

        <span class="c"># Outer Loop - Global Optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">,</span> <span class="n">FixedPointIterator</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;solver&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>So far nothing is really new in terms of syntax. Note that the top level driver, in this case an
instance of SLSQPdriver, is always named <em>&#8216;driver&#8217;</em>. However, all other drivers can be given any valid name. For this
model, we&#8217;ve chosen to use the <tt class="docutils literal"><span class="pre">FixedPointIterator</span></tt> for our solver and we named it <em>&#8216;solver&#8217;</em> in the code.</p>
<p>Next, we need to create the workflow for the solver. Add instances of <tt class="docutils literal"><span class="pre">SellarDiscipline1</span></tt>
and <tt class="docutils literal"><span class="pre">SellarDiscipline2</span></tt> to the assembly. Then add those instances to the workflow of <tt class="docutils literal"><span class="pre">'solver'</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Inner Loop - Full Multidisciplinary Solve via fixed point iteration</span>
<span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;dis1&#39;</span><span class="p">,</span> <span class="n">sellar</span><span class="o">.</span><span class="n">Discipline1</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;dis2&#39;</span><span class="p">,</span> <span class="n">sellar</span><span class="o">.</span><span class="n">Discipline2</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;dis1&#39;</span><span class="p">,</span> <span class="s">&#39;dis2&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Now the iteration hierarchy pictured above is finished. To complete the MDF architecture though,
we still need to hook up the data connections and configure the optimization and the fixed point iteration.</p>
<p>Recall that there are two global design variables, <tt class="docutils literal"><span class="pre">z1</span></tt> and <tt class="docutils literal"><span class="pre">z2</span></tt>. In the model we constructed,
you find <tt class="docutils literal"><span class="pre">z1</span></tt> in two places: <tt class="docutils literal"><span class="pre">dis1.z1</span></tt> and <tt class="docutils literal"><span class="pre">dis2.z1</span></tt>. The same is true for <tt class="docutils literal"><span class="pre">z2</span></tt>:
<tt class="docutils literal"><span class="pre">dis1.z2</span></tt> and <tt class="docutils literal"><span class="pre">dis2.z2</span></tt>. This means that when you add a parameter to the driver for <tt class="docutils literal"><span class="pre">z1</span></tt> or <tt class="docutils literal"><span class="pre">z2</span></tt>,
it needs to point to both locations in the model. We accomplish that below, by just passing a tuple of
variable names, as the first argument to the <tt class="docutils literal"><span class="pre">add_parameter</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Add Parameters to optimizer</span>
<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">((</span><span class="s">&#39;dis1.z1&#39;</span><span class="p">,</span><span class="s">&#39;dis2.z1&#39;</span><span class="p">),</span> <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">((</span><span class="s">&#39;dis1.z2&#39;</span><span class="p">,</span><span class="s">&#39;dis2.z2&#39;</span><span class="p">),</span> <span class="n">low</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>There is only one local design variable for this problem, <tt class="docutils literal"><span class="pre">x1</span></tt>, which is found in <tt class="docutils literal"><span class="pre">dis1.x1</span></tt>. Since local
design variables point to only one place in the model, we just add them using  <tt class="docutils literal"><span class="pre">add_parameter</span></tt> with a
single name as the first argument (just like we&#8217;ve shown you in previous tutorials).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;dis1.x1&#39;</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we&#8217;re using a fixed point iteration to converge the disciplines, only one of the coupling  variables
(<tt class="docutils literal"><span class="pre">y2</span></tt>) is directly varied by the solver. The other one  (<tt class="docutils literal"><span class="pre">y1</span></tt>) is just passed from  discipline 1 to
discipline 2 directly each iteration. The choice of which variable to let the solver vary and which to pass
directly is arbitrary. You could have swapped the two, and the problem would still converge.</p>
<p>To tell a FixedPointIterator which variable to vary, we just use <tt class="docutils literal"><span class="pre">add_parameter</span></tt> again.  During
iteration, this is the variable that is going to be sent to the input  of <tt class="docutils literal"><span class="pre">SellarDiscipline1</span></tt>, which is
<tt class="docutils literal"><span class="pre">'dis1y2'</span></tt>.  We setup the convergence constraint as an equality
constraint. A solver essentially tries to drive something to zero. In this case, we want to drive the
residual error in the coupled variable <tt class="docutils literal"><span class="pre">y2</span></tt> to zero. An equality constraint is defined with an expression
string which is parsed for the equals sign. In the above example, you see that <tt class="docutils literal"><span class="pre">'dis2.y2</span> <span class="pre">=</span> <span class="pre">dis1.y2'</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">'dis2.y2</span> <span class="pre">-</span> <span class="pre">dis1.y2</span> <span class="pre">=</span> <span class="pre">0'</span></tt>. We also set the maximum number of iterations and a convergence
tolerance.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Make all connections</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&#39;dis1.y1&#39;</span><span class="p">,</span><span class="s">&#39;dis2.y1&#39;</span><span class="p">)</span>

<span class="c"># Iteration loop</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;dis1.y2&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;dis2.y2 = dis1.y2&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">max_iteration</span> <span class="o">=</span> <span class="mi">100</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="o">.</span><span class="mo">00001</span>
</pre></div>
</div>
<p>Finally, the optimization is set up. We add the objective function as well as the
constraints, from the problem formulation, to the driver. The objective function includes
references to the global design variables. When this happens, you can pick any of the locations
that the global design variable points to. In this case, we used <tt class="docutils literal"><span class="pre">dis1.z2</span></tt>, but we could have
just as easily picked <tt class="docutils literal"><span class="pre">dis2.z2</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Optimization parameters</span>
<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_objective</span><span class="p">(</span><span class="s">&#39;(dis1.x1)**2 + dis1.z2 + dis1.y1 + math.exp(-dis2.y2)&#39;</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;3.16 &lt; dis1.y1&#39;</span><span class="p">)</span>
<span class="c">#Or use any of the equivalent forms below</span>
<span class="c">#self.driver.add_constraint(&#39;3.16 - dis1.y1 &lt; 0&#39;)</span>
<span class="c">#self.driver.add_constraint(&#39;3.16 &lt; dis1.y1&#39;)</span>
<span class="c">#self.driver.add_constraint(&#39;-3.16 &gt; -dis1.y1&#39;)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;dis2.y2 &lt; 24.0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As before, the <tt class="docutils literal"><span class="pre">add_constraint</span></tt> method is used to add our constraints. This time however, we used a more
general expression for the first constraint. Alternative examples of the same constraint, composed
slightly  differently, are commented out in the example below.</p>
<p>Finally, putting it all together gives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span><span class="p">,</span> <span class="n">set_as_top</span>
<span class="kn">from</span> <span class="nn">openmdao.lib.drivers.api</span> <span class="kn">import</span> <span class="n">SLSQPdriver</span><span class="p">,</span> <span class="n">FixedPointIterator</span>

<span class="kn">from</span> <span class="nn">openmdao.lib.optproblems</span> <span class="kn">import</span> <span class="n">sellar</span>

<span class="k">class</span> <span class="nc">SellarMDF</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Optimization of the Sellar problem using MDF</span>
<span class="sd">    Disciplines coupled with FixedPointIterator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new Assembly with this problem</span>

<span class="sd">        Optimal Design at (1.9776, 0, 0)</span>

<span class="sd">        Optimal Objective = 3.18339&quot;&quot;&quot;</span>

        <span class="c"># create Optimizer instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;driver&#39;</span><span class="p">,</span> <span class="n">SLSQPdriver</span><span class="p">())</span>

        <span class="c"># Outer Loop - Global Optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">,</span> <span class="n">FixedPointIterator</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;solver&#39;</span><span class="p">])</span>

        <span class="c"># Inner Loop - Full Multidisciplinary Solve via fixed point iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;dis1&#39;</span><span class="p">,</span> <span class="n">sellar</span><span class="o">.</span><span class="n">Discipline1</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;dis2&#39;</span><span class="p">,</span> <span class="n">sellar</span><span class="o">.</span><span class="n">Discipline2</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="s">&#39;dis1&#39;</span><span class="p">,</span> <span class="s">&#39;dis2&#39;</span><span class="p">])</span>

        <span class="c"># Add Parameters to optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">((</span><span class="s">&#39;dis1.z1&#39;</span><span class="p">,</span><span class="s">&#39;dis2.z1&#39;</span><span class="p">),</span> <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">((</span><span class="s">&#39;dis1.z2&#39;</span><span class="p">,</span><span class="s">&#39;dis2.z2&#39;</span><span class="p">),</span> <span class="n">low</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;dis1.x1&#39;</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">high</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span>

        <span class="c"># Make all connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&#39;dis1.y1&#39;</span><span class="p">,</span><span class="s">&#39;dis2.y1&#39;</span><span class="p">)</span>

        <span class="c"># Iteration loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;dis1.y2&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;dis2.y2 = dis1.y2&#39;</span><span class="p">)</span>

        <span class="c">#Driver settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">max_iteration</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="o">.</span><span class="mo">00001</span>

        <span class="c"># Optimization parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_objective</span><span class="p">(</span><span class="s">&#39;(dis1.x1)**2 + dis1.z2 + dis1.y1 + math.exp(-dis2.y2)&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;3.16 &lt; dis1.y1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;dis2.y2 &lt; 24.0&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span> <span class="c"># pragma: no cover</span>

    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">prob</span> <span class="o">=</span> <span class="n">set_as_top</span><span class="p">(</span><span class="n">SellarMDF</span><span class="p">())</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;top&quot;</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">dis2</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">dis2</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="mf">1.0</span>


    <span class="n">tt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="k">print</span> <span class="s">&quot;Minimum found at (</span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">z1</span><span class="p">,</span> \
                                             <span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">z2</span><span class="p">,</span> \
                                             <span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Couping vars: </span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dis1</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">prob</span><span class="o">.</span><span class="n">dis2</span><span class="o">.</span><span class="n">y2</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Minimum objective: &quot;</span><span class="p">,</span> <span class="n">prob</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">eval_objective</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;Elapsed time: &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tt</span><span class="p">,</span> <span class="s">&quot;seconds&quot;</span>


<span class="c"># End sellar_MDF.py</span>
</pre></div>
</div>
<p>This problem is contained in
<a class="reference download internal" href="../../_downloads/sellar_MDF.py"><tt class="xref download docutils literal"><span class="pre">sellar_MDF.py</span></tt></a>.
We added just a few lines at the end to instantiate the assembly class we defined and then run it and
print out some useful information. Executing it at the command line should produce
output that resembles this:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python sellar_MDF.py
Minimum found at (1.977657, 0.000000, 0.000000)
Couping vars: 3.160068, 3.755315
Minimum objective:  3.18346116811
Elapsed time:  0.121051073074 seconds
</pre></div>
</div>
<p>We initially chose to use FixedPointIterator for our solver, but you could replace that with a different
one. Fixed point iteration works for some problems, including this one, but sometimes another type of solver
might be preferred. OpenMDAO also contains a Broyden solver called <em>BroydenSolver</em>. This solver is based on
a quasi-Newton-Raphson algorithm found in <tt class="docutils literal"><span class="pre">scipy.nonlinear</span></tt>. It uses a Broyden update to approximate the
Jacobian. If we replace <tt class="docutils literal"><span class="pre">FixedPointIterator</span></tt> with <tt class="docutils literal"><span class="pre">BroydenSolver</span></tt>, the optimizer&#8217;s workflow looks like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Don&#39;t forget to put the import in your header</span>
<span class="kn">from</span> <span class="nn">openmdao.lib.drivers.api</span> <span class="kn">import</span> <span class="n">BroydenSolver</span>

<span class="c"># Outer Loop - Global Optimization</span>
<span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">,</span> <span class="n">BroydenSolver</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we set up our parameters for the inner loop. The Broyden solver is connected
using the same interface as the fixed point iterator, so that code does not change at all.
We just change some of solver specific settings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Iteration loop</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;dis1.y2&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;dis2.y2 = dis1.y2&#39;</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">itmax</span> <span class="o">=</span> <span class="mi">10</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="o">.</span><span class="mo">0000001</span>
<span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s">&quot;broyden2&quot;</span>
</pre></div>
</div>
<p>The rest of the file does not change at all either. So you can see that it&#8217;s pretty easy to reconfigure drivers
using this setup. Here is the new file, with the modifications:
<a class="reference download internal" href="../../_downloads/sellar_MDF_solver.py"><tt class="xref download docutils literal"><span class="pre">sellar_MDF_solver.py</span></tt></a>.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://openmdao.org">
 <img src="../../_static/OpenMDAO_Logo_200w_padded.png"
border="0" alt="OpenMDAO Home"/>
</a>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro.html"
                        title="previous chapter">The Sellar Problem</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="idf.html"
                        title="next chapter">Individual Design Feasible (IDF)</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/tutorials/mdao/mdf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idf.html" title="Individual Design Feasible (IDF)"
             >next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="The Sellar Problem"
             >previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../index.html" >OpenMDAO Tutorials</a> &raquo;</li>
          <li><a href="index.html" >MDAO Architectures</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright none.
      Last updated on Apr 23, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>