<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implicit Components &mdash; OpenMDAO Documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMDAO Documentation" href="../../index.html" />
    <link rel="up" title="OpenMDAO Tutorials" href="../index.html" />
    <link rel="next" title="Working with Parallel Computational Resources" href="../../concurrent.html" />
    <link rel="prev" title="Setting Up Problems for Automatic Architectures" href="../mdao/optproblem.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../concurrent.html" title="Working with Parallel Computational Resources"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../mdao/optproblem.html" title="Setting Up Problems for Automatic Architectures"
             accesskey="P">previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../index.html" accesskey="U">OpenMDAO Tutorials</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implicit-components">
<span id="tutorial-implicit"></span><h1>Implicit Components<a class="headerlink" href="#implicit-components" title="Permalink to this headline">Â¶</a></h1>
<p>In the basic tutorial, we learned how to define an OpenMDAO component that represents an
explicit function of outputs with respect to its inputs.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">F(x)</span></tt></div></blockquote>
<p>OpenMDAO also allows us to define a component that represents an implicit function of the
same variables:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">R(x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">0</span></tt></div></blockquote>
<p>Here, the variable <cite>x</cite> is a known input that is passed to the implicit
component, but the variable <cite>y</cite>, called the <cite>state</cite>, is an unknown that needs
to be solved to satisfy the equation. The left-hand side of the
implicit equation is called the <cite>residual</cite>. Since an implicit function may
not have a closed-form solution, the <cite>state</cite> is typically determined by numerically
solving the residual equation, or in other words, iterating on the state until the
residual is driven to zero.</p>
<p>An implicit equation can be solved using the base <cite>Component</cite> class in
OpenMDAO as long as the component solves the residual equations in its
<cite>execute</cite> method. However, there are some advantages to letting OpenMDAO be
aware of states and residuals. First, this allows us to define analytic
derivatives so that the implicit component can form part of the coupled
solution of the full model gradient without having to resort to finite
difference. In addition, solving the residual equations can be performed by
OpenMDAO, both locally as part of the execution of the implicit component, as well
as globally if we want to converge our implicit component simultaneously with
other solver loops in the model.</p>
<p>For the sake of convenience, we&#8217;ve broadened the definition of an implicit component
to include additional inputs and outputs that aren&#8217;t part of the implicit
equations.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">R(x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">F(x,</span> <span class="pre">y,</span> <span class="pre">u)</span></tt></p>
</div></blockquote>
<p>In this set of equations, <cite>u</cite> is an input that does not affect the residuals, and <cite>z</cite> is
an output that is not a state but satisfies an additional explicit equation. This is
analogous to the output equation of a state space model in control theory.</p>
<p>Let&#8217;s set up a simple component that can solve this set of equations, three
of which are implicit while one is explicit:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">r0(x,</span> <span class="pre">y,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">c*(3x</span> <span class="pre">+</span> <span class="pre">2y</span> <span class="pre">-</span> <span class="pre">z)</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">r1(x,</span> <span class="pre">y,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">2x</span> <span class="pre">-</span> <span class="pre">2y</span> <span class="pre">+</span> <span class="pre">4z</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">r2(x,</span> <span class="pre">y,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">-x</span> <span class="pre">+</span> <span class="pre">y/2.</span> <span class="pre">-</span> <span class="pre">z</span> <span class="pre">=0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">y_out</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">z</span></tt></p>
</div></blockquote>
<p>In these equations, the states are <cite>x</cite>, <cite>y</cite>, and <cite>z</cite>, and the residuals are
<cite>r0</cite>, <cite>r1</cite>, and <cite>r2</cite>. The variable <cite>c</cite> is a normal input, and <cite>y_out</cite> is an
explicit output. Note that the number of states must equal the number of
residuals for the system to have a unique and valid solution. We
can start defining our implicit component by inheriting from
<cite>ImplicitComponent</cite> instead of <cite>Component</cite>. This class allows the definition
of two additional iotypes: <cite>state</cite> and <cite>residual</cite>.</p>
<p>When an ImplicitComponent executes, it must solve its residual equations to
find its states. We can provide this method, or the user can implement a
<tt class="docutils literal"><span class="pre">solve</span></tt> method on the component to converge the residuals. First, we will
show an example of an implicit component that solves itself, in this case, using
fsolve from scipy.optimize.</p>
<p>Let&#8217;s write our first implicit component.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>

<span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">ImplicitComponent</span>
<span class="kn">from</span> <span class="nn">openmdao.main.datatypes.api</span> <span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Array</span>

<span class="k">class</span> <span class="nc">MyComp_No_Deriv</span><span class="p">(</span><span class="n">ImplicitComponent</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Single implicit component with 3 states and residuals.</span>

<span class="sd">    For c=2.0, (x,y,z) = (1.0, -2.333333, -2.1666667)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># External inputs</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="n">fd_step</span> <span class="o">=</span> <span class="o">.</span><span class="mo">00001</span><span class="p">,</span>
              <span class="n">desc</span><span class="o">=</span><span class="s">&quot;non-state input&quot;</span><span class="p">)</span>

    <span class="c"># States</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="s">&quot;state&quot;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="s">&quot;state&quot;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="s">&quot;state&quot;</span><span class="p">)</span>

    <span class="c"># Residuals</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">)),</span> <span class="n">iotype</span><span class="o">=</span><span class="s">&quot;residual&quot;</span><span class="p">)</span>

    <span class="c"># Outputs</span>
    <span class="n">y_out</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">iotype</span><span class="o">=</span><span class="s">&#39;out&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;run a single step to calculate the residual</span>
<span class="sd">        values for the given state var values&quot;&quot;&quot;</span>

        <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">z</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y_out</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the states that satisfy residuals using scipy.fsolve.</span>
<span class="sd">        You can override this function to provide your own internal solve.&quot;&quot;&quot;</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
        <span class="n">fsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_solve_callback</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_solve_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is passed to the internal solver to set a new state,</span>
<span class="sd">        evaluate the residuals, and return them.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residuals</span><span class="p">()</span>
</pre></div>
</div>
<p>We have taken our three residuals and placed them in a single variable array
called <cite>res</cite>, but we could also create a separate floating point variable
for each of them. Also, the initial values of our states serve as the
initial conditions for their iterative solution. Now, let&#8217;s put this in an
assembly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span><span class="p">,</span> <span class="n">set_as_top</span>

<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;comp&#39;</span><span class="p">,</span> <span class="n">MyComp_No_Deriv</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;comp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">eval_only</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
</div>
<p>and run the model. We will let the implicit component solve its own residuals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">top</span> <span class="o">=</span> <span class="n">set_as_top</span><span class="p">(</span><span class="n">Model</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># The residuals will vary depending on your system, but should be near zero.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">res</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">z</span>
<span class="go">1.0 -2.3333... -2.1666...</span>
</pre></div>
</div>
<p>The implicit component completes its iteration until the state values satisfy
the residual equations.</p>
<p>We can also configure an OpenMDAO solver to solve for the states. Here, we
set up a new assembly with the Broyden solver as the top driver. Then we
assign the states as the solver&#8217;s parameters and constrain the residuals to
be equal to zero. Also, we don&#8217;t want the implicit component&#8217;s internal
solver to solve this in competition with the BroydenSolver solver, so we set
<tt class="docutils literal"><span class="pre">eval_only</span></tt> to True. This means that running the implicit component just
runs the <cite>eval</cite> statement we defined in the class definition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openmdao.main.api</span> <span class="kn">import</span> <span class="n">Assembly</span><span class="p">,</span> <span class="n">set_as_top</span>
<span class="kn">from</span> <span class="nn">openmdao.lib.drivers.api</span> <span class="kn">import</span> <span class="n">BroydenSolver</span>

<span class="k">class</span> <span class="nc">Model2</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;comp&#39;</span><span class="p">,</span> <span class="n">MyComp_No_Deriv</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">eval_only</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;driver&#39;</span><span class="p">,</span> <span class="n">BroydenSolver</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">workflow</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;comp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;comp.x&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;comp.y&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s">&#39;comp.z&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;comp.res[0] = 0&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;comp.res[1] = 0&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="s">&#39;comp.res[2] = 0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, when we run the model, we get the same solution for the state.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">top</span> <span class="o">=</span> <span class="n">set_as_top</span><span class="p">(</span><span class="n">Model2</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># The residuals will vary depending on your system, but should be near zero.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">res</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">top</span><span class="o">.</span><span class="n">comp</span><span class="o">.</span><span class="n">z</span>
<span class="go">1.0 -2.3333... -2.1666...</span>
</pre></div>
</div>
<p>Finally, since one of the advantages to this implementation of implicit components is
in the derivative calculation, let&#8217;s specify the analytic derivatives for this simple
set of equations using the <tt class="docutils literal"><span class="pre">apply_deriv</span></tt> and <tt class="docutils literal"><span class="pre">apply_derivT</span></tt> methods. To do this, we need
to provide all permutations of the derivatives: namely, the derivatives of the residuals
with respect to both the states and the explicit inputs, and the derivatives of the
explicit output with respect to both the states and the explicit inputs. Here, we specify
these as separate Jacobians in the <tt class="docutils literal"><span class="pre">provideJ</span></tt> method, but this was purely to make the
matrix-vector multiplication in <tt class="docutils literal"><span class="pre">apply_deriv</span></tt> and <tt class="docutils literal"><span class="pre">apply_derivT</span></tt> clean and simple.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyComp_Deriv</span><span class="p">(</span><span class="n">MyComp_No_Deriv</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; This time with derivatives.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">provideJ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#partial w.r.t c</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">J_res_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J_res_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dc</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">J_output_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J_output_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">apply_deriv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>

        <span class="c"># Residual Equation derivatives</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_residuals</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>

            <span class="c"># wrt States</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_states</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_res_state</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

            <span class="c"># wrt External inputs</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;c&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_res_input</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>

        <span class="c"># Output Equation derivatives</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;y_out&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">outp</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>

                <span class="c"># wrt States</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_states</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">outp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_output_state</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

                <span class="c"># wrt External inputs</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;c&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">outp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_output_input</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">apply_derivT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>

        <span class="c"># wrt States</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_states</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>

                <span class="c"># Residual Equation derivatives</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_residuals</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_res_state</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">res</span><span class="p">])</span>

                <span class="c"># Output Equation derivatives</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;y_out&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">outp</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_output_state</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">outp</span><span class="p">]</span>

        <span class="c"># wrt External inputs</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;c&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>

                <span class="c"># Residual Equation derivatives</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_residuals</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_res_input</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">res</span><span class="p">])</span>

                <span class="c"># Output Equation derivatives</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;y_out&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">outp</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_output_input</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="n">outp</span><span class="p">]</span>
</pre></div>
</div>
<p>Specifying these derivative functions removes the need for finite differencing this
component in any workflow.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://openmdao.org">
 <img src="../../_static/OpenMDAO_Logo_200w_padded.png"
border="0" alt="OpenMDAO Home"/>
</a>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../mdao/optproblem.html"
                        title="previous chapter">Setting Up Problems for Automatic Architectures</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../concurrent.html"
                        title="next chapter">Working with Parallel Computational Resources</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/tutorials/implicit/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../concurrent.html" title="Working with Parallel Computational Resources"
             >next</a> |</li>
        <li class="right" >
          <a href="../mdao/optproblem.html" title="Setting Up Problems for Automatic Architectures"
             >previous</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../index.html">OpenMDAO Documentation v0.13.0</a> &raquo;</li>

          <li><a href="../index.html" >OpenMDAO Tutorials</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright none.
      Last updated on Apr 23, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>